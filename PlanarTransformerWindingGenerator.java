// PlanarTransformerWindingGenerator.java v1.0
// Copyright (C) 2015 Erich S. Heinzle, a1039181@gmail.com

//    see LICENSE-gpl-v2.txt for software license
//    see README.txt
//    
//    This program is free software; you can redistribute it and/or
//    modify it under the terms of the GNU General Public License
//    as published by the Free Software Foundation; either version 2
//    of the License, or (at your option) any later version.
//    
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//    
//    You should have received a copy of the GNU General Public License
//    along with this program if not, write to the Free Software
//    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//    
//    PlanarTransformerWindingGenerator.java Copyright (C) 2015 Erich S. Heinzle a1039181@gmail.com



import java.lang.Math;
import java.io.*;
import java.util.Locale;

public class PlanarTransformerWindingGenerator
{

	public static void main(String[] args) throws IOException
	{

		// this should prevent continental locales from encountering commas
		// as decimal points in the mm dimensions generated by the utility
		Locale.setDefault(new Locale("en", "US"));

		// some default values for a planar set of windings for testing

		long coreHeight = 27100; // microns
                long coreWidth = 27100; // microns
                long spaceForWindings = 7000; // microns
                
                long segmentLength = 1000; // 1mm length in microns
                int turnsPerLayer = 1;
                int turnsTotal = turnsPerLayer; // can change this when coupling of indctors is factored into inductance calcs 
                long trackGap = 300; // microns

                boolean obroundCore = true;
                boolean dualLayerCoil = false;

                boolean theOneTrueEDAsuiteGEDA = true;
                	// obviously, !theOneTrueEDAsuiteGEDA = kicad :-)

                
		int vertices = 4;

		// we now parse arguments parsed via the command line

		if (args.length == 0)
		{
			printUsage();
			System.exit(0);
		}

		for (int counter = 0; counter < args.length; counter++)
		{
			if (args[counter].startsWith("-n"))
			{
				turnsPerLayer = Integer.parseInt(args[counter+1]);
				counter++;
			}
                        else if (args[counter].startsWith("-w"))
                        {
                                coreWidth = Long.parseLong(args[counter+1]);
                                counter++;
                        }
                        else if (args[counter].startsWith("-h"))
                        {
                                coreHeight = Long.parseLong(args[counter+1]);
                                counter++;
                        }
                        else if (args[counter].startsWith("-s"))
                        {
                                spaceForWindings = Long.parseLong(args[counter+1]);
                                counter++;
                        }
                        else if (args[counter].startsWith("-g"))
                        {
                                trackGap = Long.parseLong(args[counter+1]);
                                counter++;
                        }
                        else if (args[counter].startsWith("-k"))
                        {
                                theOneTrueEDAsuiteGEDA = false;
                        }
                        else if (args[counter].startsWith("-l"))
                        {
                                segmentLength = Long.parseLong(args[counter+1]);
                                counter++;
                        }
			else if (args[counter].startsWith("-q"))
			{
				vertices = 4;
                                obroundCore = false; // we flag it
				System.out.println("Core is a quadrilateral, not obround.");
			}
                        else if (args[counter].startsWith("-d"))
                        {
                                dualLayerCoil = true;
                        }
                        else 
                        {
                                printUsage();
				System.exit(0);
                        }
			
		}

		// some basic preliminaries for all scenarios

                // first, we make sure we are dealing with a coreHeight >= coreWidth
                long tempVar = 0;
                if (coreHeight < coreWidth)
                {
                    tempVar = coreHeight;
                    coreHeight = coreWidth;
                    coreWidth = tempVar;
                }

                // now, we figure out if the core is square or round,
                // as opposed to elongated lengthwise, and flag it
                long stretchedBy = coreHeight - coreWidth; // microns
                long stretchFactor = 0;
                long RUQoffsetFactor = 0;
                boolean elongatedCore = false;
                boolean elongationUnderway = false;
                boolean pauseTheta = false;

                if (stretchedBy != 0)
                {
                    elongatedCore = true;
                }

                long trackWidth = (spaceForWindings - ((turnsPerLayer + 1 ) * trackGap))/turnsPerLayer; // microns

                double startRadius = (coreWidth + trackWidth)/2.0 + trackGap;

                long radiusIncrementPerTurn = trackWidth + trackGap;

		double nextRadius = startRadius + radiusIncrementPerTurn;

		// now some preliminaries for obround windings
                // we now sort out appropriate angular step sizes for the loops and
                // the loop spacings based on the inner and outer dimensions given

                double theta = 0;
                double nextTheta = 0;
                double startTheta = 0;
                double endTheta = 2.0*Math.PI;

		// we figure out the circumference
		double circumference = Math.PI * (coreWidth + spaceForWindings - trackGap - trackWidth/2.0);

		// we base segments per loop on the outermost loop circumference
                // and try to get an integer amount >=1 of segments per quadrant
                // as this will simplify stretching of obround coils in the Y direction

                long segmentsPerQuadrant = (long)Math.ceil(circumference/segmentLength/4.0);
		long segmentsPerLoop = 4 * segmentsPerQuadrant;
                long segmentCount = 0; // used for circular winding generation
                long loopSegmentCount = 0; //used to determine timing for stretch, if needed

		// we figure out a step size in radians to step around the spiral
                // which is 2pi radians divided by number of segments
		double deltaTheta = (2.0 * Math.PI)/segmentsPerLoop;

		// we now define some flags
		boolean nextTurnPlease = false;


		// we use x1,y1,x2,y2 as variables for the begining and end coords of line segments
		double x1 = 0;
		double y1 = 0;
		double x2 = 0;
		double y2 = 0;

                // we use x1scales,y1scaled,x2scaled,y2scaled as variables for
		// the beginning and end coords of scaled helical coil segments
		// for capacitance length calculation
                double x1scaled = 0;
                double y1scaled = 0;
                double x2scaled = 0;
                double y2scaled = 0;

		long layerNumber = 15; // front for kicad

		String moduleName = "";

                if (obroundCore && dualLayerCoil)
                {
                    moduleName = (2 * turnsPerLayer) + "_turn_obround_planar_transformer_winding";
                }
                else if (!obroundCore && dualLayerCoil)
                {
                    moduleName =  (2 * turnsPerLayer) + "_turn_quadrilateral_planar_transformer_winding";
                }
                else if (obroundCore && !dualLayerCoil)
                {
                    moduleName = (turnsPerLayer) + "_turn_obround_planar_transformer_winding";
                }
                else if (!obroundCore && !dualLayerCoil)
                {
                    moduleName =  (turnsPerLayer) + "_turn_quadrilateral_planar_transformer_winding";
                }


		String outputFileName = "";
	
		if (theOneTrueEDAsuiteGEDA)
		{
			outputFileName = moduleName + ".fp";
		}
		else //kicad
		{
			outputFileName = moduleName + ".mod";
		}


                if (dualLayerCoil)
                    {
                        System.out.println("Dual layer coil being generated.");
                    }
                else
                    {
                        System.out.println("Single layer coil being generated.");
                    }
		System.out.println("Generating " + turnsPerLayer + " turn per layer, inductor: " +
			outputFileName);

		System.out.println("Using track gap of: " + trackGap + " microns.");
		System.out.println("Using track width of: " + trackWidth + " microns.");

		File outputFile = new File(outputFileName);

		PrintWriter footprintOutput = new PrintWriter(outputFile);

		String headerString = "";

		if (theOneTrueEDAsuiteGEDA)
		{
			headerString = headerString +
				("Element[\"\" \"Inductor\"" + 
				" \"\" \"\" 0 0 -1000 -1000 0 100 \"\"]" +
				"(\n");
		}
		else // kicad :-)
		{
                	headerString = headerString +
				"PCBNEW-LibModule-V1  mer 27 mar 2013 20:53:24 CET\n" +
                                "Units mm\n" +
                                "$INDEX\n" +
                                moduleName + "\n" +
                                "$EndINDEX\n" +
                                "$MODULE " + moduleName + "\n" +
                                "Po 0 0 0 15 51534DFF 00000000 ~~\n" +
                                "Li " + moduleName + "\n" +
                                "Cd " + moduleName + "\n" +
                                "Sc 0\n" +
                                "AR\n" +
                                "Op 0 0 0\n" +
                                "T0 0 -4134 600 600 0 120 N V 21 N \"S***\"\n";
		}

		footprintOutput.print(headerString);

                long currentLoopStartX = 0;
                long currentLoopStartY = 0;

                double trackWidthMM = trackWidth/1000.0;
		double trackGapMM = trackGap/1000.0;

                int segmentCountPerTurn = 0;

		// we need to calculate the effective length of the distributed capacitor
                double cumulativeCapacitorLengthMM = 0.0;

		// and length of trace will allow coil resistance to be calculated
		double cumulativeCoilLengthMM = 0.0;

		for (long spiralCounter = 0; spiralCounter < turnsPerLayer; spiralCounter++)
		{
                    loopSegmentCount = 0; // reset segment count 
			if (!obroundCore) // we are making a quadrilateral winding, as opposed to obround windings
			{
                            // we use theta to create a square rather than a rotated square == rhomboid
				theta = Math.PI/4.0;

				// we step through, one vertex after another, until we complete a turn
				for (int vertexCount = 0; vertexCount < (vertices + 2); vertexCount++)
				{
                                    switch (vertexCount)
                                        {
                                        case 0:
                                            x1 = (radiusIncrementPerTurn * spiralCounter)/1000.0; // we could an offset here for double via, turn 0
                                            y1 = - (coreWidth/2.0 + trackGap + trackWidth/2.0 + (radiusIncrementPerTurn*spiralCounter))/1000.0;
	                        	    x2 = - (coreWidth/2.0 + trackGap + trackWidth/2.0 + (radiusIncrementPerTurn*spiralCounter))/1000.0;
	                        	    y2 = y1;
                                            break;
                                        case 1:
                                            x1 = x2;
                                            y1 = y2;
                                            x2 = x1;
                                            y2 = (coreWidth/2.0 + trackGap + trackWidth/2.0 + stretchedBy
                                                  + (radiusIncrementPerTurn*spiralCounter))/1000.0;
                                            break;
                                        case 2:
                                            x1 = x2;
                                            y1 = y2;
                                            x2 = (coreWidth/2.0 + trackGap + trackWidth/2.0 + (radiusIncrementPerTurn*spiralCounter))/1000.0;
                                            y2 = y1;
                                            break;
                                        case 3:
                                            x1 = x2;
                                            y1 = y2;
                                            x2 = x1;
                                            y2 = - (coreWidth/2.0 + trackGap + trackWidth/2.0 + (radiusIncrementPerTurn*spiralCounter))/1000;
                                            break;
                                        case 4:
                                            x1 = x2;
                                            y1 = y2;
                                            if (turnsPerLayer > 2)
                                                {
                                                    x2 = radiusIncrementPerTurn * (spiralCounter + 2)/1000.0;
                                                    // we could think about an offset here for double via, turn 0
                                                }
                                            else
                                                {
                                                    x2 = x1; // this takes care of degenerate cases with turns = 1, 2
                                                }
                                            y2 = y1;
                                            break;
                                        case 5:
                                            x1 = x2;
                                            y1 = y2;
                                            x2 = radiusIncrementPerTurn * (spiralCounter + 1)/1000.0;  // we could an offset here for double via, turn 0
                                            y2 = y1 - radiusIncrementPerTurn/1000.0;
                                            break;

					}

					// we only have capacitance between turns, so we stop
					// summing capacitance length when generating the
					// final turn, i.e. stop at (turnsPerLayer - 1)

	                                if (spiralCounter < (turnsPerLayer - 1))
	                                {
	                                        cumulativeCapacitorLengthMM +=
	                                                calculateSegmentLength(x1, y1, x2, y2)
	                                                + ((radiusIncrementPerTurn/1000.0) * Math.tan(Math.PI/vertices));
	                                }

					// we add the segment length to the total coil length 
					cumulativeCoilLengthMM += calculateSegmentLength(x1, y1, x2, y2);

					if (theOneTrueEDAsuiteGEDA)
	                                {

                                            // for gEDA we have to produce a pad description of the form
                                            // Pad[X1 Y1 X2 Y2 Thickness Clearance Mask Name Number SFlags]
	                                        footprintOutput.format("Pad[%.3fmm %.3fmm %.3fmm %.3fmm", x1, y1, x2, y2);
	                                        footprintOutput.format(" %.3fmm ", trackWidthMM);
	                                        footprintOutput.print("0.254mm "); // the clearance is 10mil
	                                        footprintOutput.print("0 "); // solder mask clearance is zero
	                                        footprintOutput.print("\"A\" "); // name of coil
	                                        footprintOutput.print("\"1\" "); // coil pad number
	                                        footprintOutput.print("\"\"]\n"); // flags, if any


                                                if (dualLayerCoil)
                                                    {
                                                        footprintOutput.format("Pad[%.3fmm %.3fmm %.3fmm %.3fmm", -x1, y1, -x2, y2);
                                                        footprintOutput.format(" %.3fmm ", trackWidthMM);
                                                        footprintOutput.print("0.254mm "); // the clearance is 10mil
                                                        footprintOutput.print("0 "); // solder mask clearance is zero
                                                        footprintOutput.print("\"A\" "); // name of coil
                                                        footprintOutput.print("\"1\" "); // coil pad number
                                                        footprintOutput.print("\"onsolder\"]\n"); // flag
                                                    }
	                                }
	                                else // kicad
	                                {

		                                // for kicad we have to produce
		                                // a Draw Segment "DS" string of the form
	        	                        // "DS x1 y1 x2 y2 thickness layer"

	                                        footprintOutput.format("DS %.3f %.3f %.3f %.3f", x1, y1, x2, y2);
	                                        footprintOutput.format(" %.3f ", trackWidthMM);
	                                        footprintOutput.println(layerNumber);

                                            if (dualLayerCoil)
                                                {
                                                    footprintOutput.format("DS %.3f %.3f %.3f %.3f", -x1, y1, -x2, y2);
                                                    footprintOutput.format(" %.3f ", trackWidthMM);
                                                    footprintOutput.println(0); // bottom layer
                                                }
	                                }


				}
			} // end quadrilateral core if statement

			else // if (obroundCore) // not a quadrilateral core, it is obround
			{
                            // we need to start at PI/2 for each turn, 
                            // An additional complication is adding a "stretch" to the coil after the coil
                            // loop is at Pi radians, and when back at 0 radians, to effect an obround
                            // loop if required
                            // we also translate in -ve y direction, to shift the final RUQ of the coil
                            // to meet the next loop, when theta >= 2.0*Math.PI, i.e. RUQ

                            // we start at the top, and move clockwise with the commencement of each new turn
                            
                            startTheta = Math.PI/2.0;
                            theta = startTheta;

                            segmentCount = 0; // first segment for this loop about to start 

                            boolean finalRUQstretchDone = false;

                            startRadius = coreWidth/2.0 + trackGap + trackWidth/2.0 + (spiralCounter * radiusIncrementPerTurn);

                            x2 = ((startRadius * Math.cos(startTheta))/1000.0); // our starting x,y for the new turn
                            y2 = -((startRadius * Math.sin(startTheta))/1000.0);

                            // System.out.println("StartRadius: " + startRadius + "\nTheta: " + theta 
                            //                   + "\nSegmentCount: " + segmentCount);

                            while (theta < (5.0*Math.PI/2.0))
				{
					// we figure out the coordinates in mm as double variables 
					// gEDA will recognise "XXX.XXmm" as mm
					x1 = x2;
                                        y1 = y2;

                                        // we know how many segments there are per quadrant, so, we test
                                        // to see if the obround winding needs to be stretched in the Y
                                        // direction (i.e. core height) between PI and 2*PI radians...
                                        // we also test to see if we have just passed 2*PI radians
                                        // and need to stretch the coil in the -ve Y direction by an
                                        // amount equal to radiusIncrementPerTurn to make the final quadrant
                                        // of coil meet the beginning of the next turn...

                                        if ((segmentCount == segmentsPerQuadrant) && elongatedCore && !elongationUnderway)
                                            {
                                                stretchFactor = stretchedBy;
                                                elongationUnderway = true;
                                                pauseTheta = true;
                                            }
                                        else if ((segmentCount == 3*segmentsPerQuadrant) && elongationUnderway)
                                            {
                                                stretchFactor = 0;
                                                elongationUnderway = false;
                                                RUQoffsetFactor = radiusIncrementPerTurn;
                                                pauseTheta = true;
                                            }
                                        else if (elongationUnderway)
                                            {
                                            }
                                        else if ((segmentCount == 3*segmentsPerQuadrant) && !elongatedCore && !finalRUQstretchDone)
                                            {
                                                stretchFactor = 0;
                                                RUQoffsetFactor = radiusIncrementPerTurn;
                                                pauseTheta = true;
                                                finalRUQstretchDone = true;
                                            }
                                        else if ((segmentCount >= 3*segmentsPerQuadrant))
                                            {
                                                stretchFactor = 0;
                                                RUQoffsetFactor = radiusIncrementPerTurn;
                                            }
                                        else // i.e. (in first quadrant) || (!elongatedCore and (in first 3 quadrants))
                                            {
                                                stretchFactor = 0;
                                                RUQoffsetFactor = 0;
                                                pauseTheta = false;
                                            }

                                        if (!pauseTheta)
                                            {
                                                nextTheta = theta + deltaTheta;
                                                segmentCount++;
                                            }
                                        else // i.e.  if (pauseTheta) to stretch things is underway
                                            {
                                                pauseTheta = false;
                                            }


                                        // we also need to test if it is the final loop, so that the coil
                                        // can be terminated in a straight track
                                        // so, we test to see if we are at the last turn
                                        if ((spiralCounter == (turnsPerLayer-1)) && (segmentCount == (3*segmentsPerQuadrant +1)) && (finalRUQstretchDone || !elongationUnderway))
                                        // we're about to embark on start final turn, going into the RUQ of this turn
                                            {
                                                x2 = x1;
                                                y2 = y1 - (startRadius + stretchFactor)/1000.0;
                                                // no curve, go straight up
                                                nextTheta = theta + Math.PI; // and terminate the while loop
                                            }
                                        else // not the last quadrant of the last turn
                                            {
                                                x2 = ((startRadius * Math.cos(nextTheta))/1000.0);
                                                y2 = -((startRadius * Math.sin(nextTheta) - stretchFactor + RUQoffsetFactor)/1000.0);
                                            }

					// we numerically integrate the length of the midline
					// between turns, hence the use of the + (trackGap/2.0)
					// to estabish the midline of the gap

                                                 // broken

                                        x1scaled = ((startRadius + (trackGap/2.0))* Math.cos(theta))/1000.0;
                                        y1scaled = ((startRadius + (trackGap/2.0))* Math.sin(theta))/1000.0;
                                        x2scaled = ((nextRadius + (trackGap/2.0))* Math.cos(nextTheta))/1000.0;
                                        y2scaled = ((nextRadius + (trackGap/2.0))* Math.sin(nextTheta))/1000.0;


					// there is only capacitance between turns, so we stop summing
					// capacitor length at (turnsPerLayer -1)

	                                if (spiralCounter < (turnsPerLayer - 1))
        	                        {
                	                        cumulativeCapacitorLengthMM +=
                        	     calculateSegmentLength(x1scaled, y1scaled, x2scaled, y2scaled);
                                	}

                                        // we add the segment length to the total coil length 
                                        cumulativeCoilLengthMM += calculateSegmentLength(x1, y1, x2, y2);


					if (theOneTrueEDAsuiteGEDA)
					{

                                            // for gEDA we have to produce a pad description of the form
                                            // Pad[X1 Y1 X2 Y2 Thickness Clearance Mask Name Number SFlags]
						footprintOutput.format("Pad[%.3fmm %.3fmm %.3fmm %.3fmm", x1, y1, x2, y2);
                        	                footprintOutput.format(" %.3fmm ", trackWidthMM);
						footprintOutput.print("0.254mm "); // the clearance is 10mil
						footprintOutput.print("0 "); // solder mask clearance is zero
						footprintOutput.print("\"A\" "); // name of coil
						footprintOutput.print("\"1\" "); // coil pad number
						footprintOutput.print("\"\"]\n"); // flags, if any

                                                if (dualLayerCoil)
                                                    {// we now produce the mirror image on the bottom layer
                                                        footprintOutput.format("Pad[%.3fmm %.3fmm %.3fmm %.3fmm", -x1, y1, -x2, y2);
                                                        footprintOutput.format(" %.3fmm ", trackWidthMM);
                                                        footprintOutput.print("0.254mm "); // the clearance is 10mil
                                                        footprintOutput.print("0 "); // solder mask clearance is zero
                                                        footprintOutput.print("\"A\" "); // name of coil
                                                        footprintOutput.print("\"1\" "); // coil pad number
                                                        footprintOutput.print("\"onsolder\"]\n"); // bottom layer flag
                                                    }
					}
					else // kicad
					{
						// for kicad we have to produce
						// a Draw Segment "DS" string of the form
						// "DS x1 y1 x2 y2 thickness layer"
						footprintOutput.format("DS %.3f %.3f %.3f %.3f", x1, y1, x2, y2);
						footprintOutput.format(" %.3f ", trackWidthMM);
						footprintOutput.println(layerNumber);

                                                if (dualLayerCoil)
                                                    {// we now produce the mirror image on the bottom layer
                                                        footprintOutput.format("DS %.3f %.3f %.3f %.3f", -x1, y1, -x2, y2);
                                                        footprintOutput.format(" %.3f ", trackWidthMM);
                                                        footprintOutput.println(0); // bottom layer
                                                    }
					}
                                        
                                        theta = nextTheta;
                                

				}
			}// end obround winding IF statement
		}

		if (theOneTrueEDAsuiteGEDA) // :-)
		{
			footprintOutput.println(")");
		}
		else // kicad
		{
                	footprintOutput.println("$EndMODULE " + moduleName);
		}

                long innerDiameter = coreWidth + (trackGap * 2);
                long outerDiameter = coreWidth + spaceForWindings - (trackGap * 2);

		System.out.println("Outer (minor) diameter of winding including track gaps (mm): " + (coreWidth + spaceForWindings)/1000.0);
		System.out.println("Inner (minor) diameter of windings including track gaps (mm): " + (coreWidth)/1000.0);
		if (obroundCore)
		{
			System.out.println("Windings are rounded.");
		}
		else
		{
			System.out.println("Windings have quadrilateral geometry.");
		}

		System.out.print("Total coil length (mm): ");
		System.out.format("%.4f\n", cumulativeCoilLengthMM);
		System.out.print("DC resistance of coil assuming copper resistivity = 1.75E-8 ohm\n\t35.56 micron copper thickness: ");
		System.out.format("%.4f ohm\n", (1.75E-8*(cumulativeCoilLengthMM/1000.0)/((trackWidthMM/1000.0)*(3.556E-5))));
                System.out.print("\t71.12 micron copper thickness: ");
                System.out.format("%.4f ohm\n", (1.75E-8*(cumulativeCoilLengthMM/1000.0)/((trackWidthMM/1000.0)*(7.112E-5))));

                System.out.println("The following capacitance and inductance calculations are\n" + 
                                   "based on minor diameters of coils, so they are unlikely to\n" +
                                   "be accurate, unless windings are circular or square.");
 		System.out.print("Total capacitor length (mm): ");
		System.out.format("%.4f\n", cumulativeCapacitorLengthMM);

		double finalCapacitanceF = calculateCapacitance(trackGapMM,cumulativeCapacitorLengthMM);
		
		System.out.println("Total calculated capacitance (F): " + finalCapacitanceF);
                System.out.print("Total calculated capacitance (pF): ");
		System.out.format("%.4f\n", (finalCapacitanceF*1E12));

                // the following variables are used to calculate inductance
                // using the "Greenhouse" equation for flat "pancake" inductors
                // we set the default values to those needed for a helical coil

                double greenhouseC1 = 1.00; // Square 1.27, Hexagonal 1.09, Circle 1.00
                double greenhouseC2 = 2.46; // Square 2.07, Hexagonal 2.23, Circle 2.46
                double greenhouseC3 = 0.00; // Square 0.18, Hexagonal 0.00, Circle 0.00
                double greenhouseC4 = 0.20; // Square 0.13, Hexagonal 0.17, Circle 0.20

		if (!obroundCore) // i.e. (vertices == 4)
                    {
                	greenhouseC1 = 1.27; // Square 1.27, Hexagonal 1.09, Circle 1.00
                	greenhouseC2 = 2.07; // Square 2.07, Hexagonal 2.23, Circle 2.46
                	greenhouseC3 = 0.18; // Square 0.18, Hexagonal 0.00, Circle 0.00
                	greenhouseC4 = 0.13; // Square 0.13, Hexagonal 0.17, Circle 0.20
                        if (elongatedCore)
                            {
                                System.out.println("Using Greenhouse equation for a square, but the coil is " +
                                       "rectangular,\nso the accuracy of inductance calculations will be affected.");
                            }
                    }
                else if (obroundCore && elongatedCore)
                    {
                        System.out.println("Using Greenhouse equation for a helix, but the coil is not circular," + 
                                           "\nso the accuracy of inductance calculations will be affected.");
                    }

		double finalInductanceH = calculateInductance(turnsTotal, innerDiameter, outerDiameter, greenhouseC1, greenhouseC2, greenhouseC3, greenhouseC4);
		
 		System.out.println("Calculated inductance (Henries): " + finalInductanceH);
                System.out.print("Calculated inductance (uH): ");
                System.out.format("%.4f\n", (finalInductanceH*1000000));
		System.out.print("Calculated self resonant frequency (Hz): ");
		System.out.format("%.0f\n", calculateSelfResonance(finalInductanceH, finalCapacitanceF));
                System.out.print("Calculated self resonant frequency (MHz): ");
		System.out.format("%.4f\n", calculateSelfResonance(finalInductanceH, finalCapacitanceF)/1E6);
		// and we close the footprint file before finishing up
		footprintOutput.close();
	}

	private static double calculateSelfResonance(double inductanceHenries, double capacitance)
	{
                // method employed described in http://dx.doi.org/10.4236/cs.2013.42032
                // "Design and Optimization of Printed Circuit Board
                // Inductors for Wireless Power Transfer System" by
                // Ashraf B. Islam, Syed K. Islam, Fahmida S. Tulip
                // Circuits and Systems, 2013, 4, 237-244

		// we use frequency = 1/(2*pi*sqrt(LC)) 
		return (1.0/(2.0*Math.PI*Math.sqrt(inductanceHenries*capacitance)));
	}

	private static double calculateSegmentLength(double xOne, double yOne, double xTwo, double yTwo)
	{
		double lengthSquared = ((xOne - xTwo) * (xOne - xTwo))+((yOne - yTwo) * (yOne - yTwo));
		return Math.sqrt(lengthSquared);
	}

	private static double calculateCapacitance(double trackGapMilliM, double gapLengthMilliM)
	{
                // method employed described in http://dx.doi.org/10.4236/cs.2013.42032
                // "Design and Optimization of Printed Circuit Board
                // Inductors for Wireless Power Transfer System" by
                // Ashraf B. Islam, Syed K. Islam, Fahmida S. Tulip
                // Circuits and Systems, 2013, 4, 237-244
		double etaRC = 3.1; // solder mask relative permittivity a.k.a. dielectric constant
		double etaRS = 4.7; // approx, fibreglass relative permittivity (dielectric constant)
				// etaRA = 1.006 for air at STP at ~ 0.9MHz
		double alpha = 0.9; // for FR4 coating
		double beta = 0.1; // for FR4 substrate	
		double eta0 = 8.854E-12; // dielectric constant of a vacuum	
		double copperThicknessM = 0.00003556; // in metres = 35.56 microns for 1oz/ft^2 copper
		double trackGapM = trackGapMilliM/1000.0; // convert mm to metres
		double gapLengthM = gapLengthMilliM/1000.0; // convert mm to metres
		double calculatedCapacitance = (alpha*etaRC + beta*etaRS)*eta0*copperThicknessM*gapLengthM/trackGapM;
		// i.e. the formula for parallel plates of a capacitor
		//            = (plateArea/gap)*dielectricConstantOfVacuum*relativePermittivity
		return calculatedCapacitance;
	}

	private static double calculateInductance(int turns, long dIn, long dOut, double c1, double c2, double c3, double c4)
	{
		// method employed described in http://dx.doi.org/10.4236/cs.2013.42032
		// "Design and Optimization of Printed Circuit Board
		// Inductors for Wireless Power Transfer System" by
		// Ashraf B. Islam, Syed K. Islam, Fahmida S. Tulip
		// Circuits and Systems, 2013, 4, 237-244
		double dAvg = ((dOut + dIn)/1000000.0)/2.0; // convert distance in microns to metres
		double sigma = (dOut - dIn)/(1.0*(dOut + dIn)); // sigma = "coil fill ratio"
		double mu = 4*Math.PI/10000000; // vacuum permeability = 4*pi * 10^(-7)
		double inductance = 0;
		inductance = ((mu * turns * turns * dAvg * c1)/2.0)*(Math.log(c2/sigma) + c3*sigma + c4*sigma*sigma);
		return inductance; // in Henries (H)
	}

	private static void printUsage()
	{
		System.out.println("\nUsage:\n\n\t" +
			"java PlanarTransformerWindingGenerator -option value\n" +
			"\n\t\t-k\texport a kicad module, default is geda .fp file\n" +
                        "\n\t\t-n\tturns per layer for the windings\n" +
                        "\n\t\t-w long\twidth of core in microns\n" +
                        "\n\t\t-h long\theight of core in microns\n" +
                        "\n\t\t-s long\tspace available for windings in microns\n" +
                        "\n\t\t-g long\ttrack gaps in microns\n" +
                        "\n\t\t-q\tgenerate a quadrilateral rather than rounded winding\n" +
			"\n\t\t-l long\tlength of segment used to approximate circular arc in microns\n" +
                        "\n\t\t-s\tgenerate a two layer winding (that will need the addition of a via to series connect\n" +
			"\n\t\t-h\t prints this\n\n" +
			"Example usage:\n\n\t" +

                        "java PlanarTransformerWindingGenerator -w 20000 -h 30000 -n 5 -s 10000 -g 300 -l 2500 -d\n\n\t" +                                   
			"generates a dual layer, 5 turn per layer, 10 turn obround winding,\n\t" +
			"of 20mm inside width, 30 mm inside height, with a winding width of 10mm\n\t" +
			"with 0.3mm track gap and 2.5mm segment length.\n\n\n\t" +
                        "java PlanarTransformerWindingGenerator -w 20000 -h 30000 -n 5 -s 10000 -g 300 -l 2500 -d -q -k\n\n\t" +
			"generates a dual layer, 5 turn per layer, 10 turn rectangular winding,\n\t" +
			"of 20mm inside width, 30 mm inside height, with a winding width of 10mm,\n\t" +
			"with a 0.3mm track gap, in kicad legacy module format.\n\n\n\t");
	}
}
